use std::{fs, io::BufRead, path::PathBuf};

use clap::ValueEnum;

use crate::frontend::ast::LeekAst;

use self::{
    codegen::{CodeGenTarget, CodeGenerator},
    optimization::OptimizationLevel,
};

pub mod codegen;
pub mod optimization;

#[derive(Debug, Default)]
pub enum BuildMode {
    #[default]
    Debug,
    Release,
}

#[derive(Debug, Default, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, ValueEnum)]
pub enum EmitMode {
    #[default]
    #[value(name = "exe", help = "executable file")]
    ExecutableFile,
    #[value(name = "obj", help = "object file")]
    ObjectFile,
    #[value(name = "asm", help = "assembly file")]
    AssemblyFile,
}

pub struct CompilerOptions {
    pub opt_level: OptimizationLevel,
    pub build_mode: BuildMode,
    pub emit_mode: EmitMode,
    pub input_file: PathBuf,
    pub output_name: Option<PathBuf>,
    pub verbose: bool,
}

#[derive(Debug)]
pub enum CodeGenError {
    FileOutputFailure,
    TemporaryDirectoryCreationFailure,
    TemporaryFileCreationFailure,
    AssemblerError,
    LinkerError,
}

macro_rules! display_buffer {
    ($buffer:expr, $name:literal, $buf_name:literal) => {
        $buffer
            .lines()
            .filter_map(|line| line.ok())
            .for_each(|line| println!("[{}] ({}): {}", $name, $buf_name, line));
    };
}

pub fn compile_ast(
    ast: LeekAst,
    compiler_options: CompilerOptions,
    target: CodeGenTarget,
) -> Result<(), CodeGenError> {
    let code_generator = target.get_code_generator();

    // If the output name is specified, use that.
    // Otherwise compute the correct name based on the input file.
    let output_path = match &compiler_options.output_name {
        Some(n) => n.clone(),
        None => {
            let base_name = compiler_options.input_file.clone();

            match compiler_options.emit_mode {
                EmitMode::ExecutableFile => base_name.with_extension(""),
                EmitMode::ObjectFile => base_name.with_extension("o"),
                EmitMode::AssemblyFile => base_name.with_extension("s"),
            }
        }
    };

    /* Step 0. Create a temporary directtory to work in */

    const LEEK_TMP_PATH: &str = "/tmp/leek";

    // Create a temporary directory to work in
    let build_dir = fs::create_dir_all(LEEK_TMP_PATH)
        .and_then(|_| mktemp::Temp::new_dir_in(LEEK_TMP_PATH))
        .map_err(|_| CodeGenError::TemporaryDirectoryCreationFailure)?;

    /* Step 1. Code Generation */

    // Create a temporary file to pass to the assembler
    let assembly_file_path = build_dir.join("program.s");

    // Dynamically generate the assembly based on the compile target's code generator
    let assembly = code_generator.generate_assembly(ast, &compiler_options);

    // TODO: Add a "generated by" header to the file

    // Write the assembly file to disk
    fs::write(&assembly_file_path, assembly)
        .map_err(|_| CodeGenError::TemporaryFileCreationFailure)?;

    // If all we want is to generate asm, then write to disk and stop here
    if let EmitMode::AssemblyFile = compiler_options.emit_mode {
        fs::copy(assembly_file_path, output_path).map_err(|_| CodeGenError::FileOutputFailure)?;
        return Ok(());
    }

    /* Step 2. Assembling */

    // Create a temporary file to pass to the linker
    let object_file_path = build_dir.join("program.o");

    // Invoke the assembler to create the object file
    let mut assembler_command =
        code_generator.create_assembler_command(&assembly_file_path, &object_file_path);

    let output = assembler_command
        .output()
        .expect("Could not invoke assembler!");

    if !output.status.success() {
        // Break on assembler error
        display_buffer!(output.stderr, "ASSEMBLER", "STDERR");
        return Err(CodeGenError::AssemblerError);
    } else if compiler_options.verbose {
        // Print assembler output if verbose is passed
        display_buffer!(output.stdout, "ASSEMBLER", "STDOUT");
    }

    // If all we want is to generate an object file, then write to disk and stop here
    if let EmitMode::ObjectFile = compiler_options.emit_mode {
        fs::copy(object_file_path, output_path).map_err(|_| CodeGenError::FileOutputFailure)?;
        return Ok(());
    }

    /* Step 3. Linking */

    // Create a temporary file to pass to the linker
    let executable_file_path = build_dir.join("program");

    let mut linker_command =
        code_generator.create_linker_command(&object_file_path, &executable_file_path);

    let output = linker_command.output().expect("Could not invoke linker!");

    if !output.status.success() {
        // Break on linker error
        display_buffer!(output.stderr, "LINKER", "STDERR");
        return Err(CodeGenError::LinkerError);
    } else if compiler_options.verbose {
        // Print linker output if verbose is passed
        display_buffer!(output.stdout, "LINKER", "STDOUT");
    }

    fs::copy(executable_file_path, output_path).map_err(|_| CodeGenError::FileOutputFailure)?;

    /* Step 4. Celebrate! We compiled our program! */

    Ok(())
}
