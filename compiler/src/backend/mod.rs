use std::{fs, io::BufRead};

use itertools::Itertools;

use crate::{
    common::{
        config::{EmitMode, LeekCompilerConfig},
        error::LeekCompilerError,
    },
    frontend::ast::LeekAst,
};

use self::codegen::{CodeGenTarget, CodeGenerator};

pub mod codegen;

#[derive(Debug)]
pub enum CodeGenError {
    FileOutputFailure,
    TemporaryDirectoryCreationFailure,
    TemporaryFileCreationFailure,
    AssemblerError,
    LinkerError,
}

macro_rules! display_buffer {
    ($buffer:expr, $name:literal, $buf_name:literal) => {
        $buffer
            .lines()
            .map_while(Result::ok)
            .for_each(|line| println!("[{}] ({}): {}", $name, $buf_name, line));
    };
}

pub fn compile_ast(
    ast: LeekAst,
    compiler_options: &LeekCompilerConfig,
    target: CodeGenTarget,
) -> Result<(), LeekCompilerError> {
    let code_generator = target.get_code_generator();

    // If the output name is specified, use that.
    // Otherwise compute the correct name based on the input file.
    let output_path = match &compiler_options.output_name {
        Some(n) => n.clone(),
        None => {
            let base_name = compiler_options.input_files[0].clone();

            match compiler_options.emit_mode {
                EmitMode::ExecutableFile => base_name.with_extension(""),
                EmitMode::ObjectFile => base_name.with_extension("o"),
                EmitMode::AssemblyFile => base_name.with_extension("s"),
            }
        }
    };

    /* Step 0. Create a temporary directtory to work in */

    const LEEK_TMP_PATH: &str = "/tmp/leek";

    // Create a temporary directory to work in
    let build_dir = fs::create_dir_all(LEEK_TMP_PATH)
        .and_then(|_| mktemp::Temp::new_dir_in(LEEK_TMP_PATH))
        .map_err(|_| CodeGenError::TemporaryDirectoryCreationFailure)?;

    /* Step 1. Code Generation */

    // Create a temporary file to pass to the assembler
    let assembly_file_path = build_dir.join("program.s");

    // Dynamically generate the assembly based on the compile target's code generator
    let assembly = code_generator.generate_assembly(ast, compiler_options);

    // Prepend the assembly with a header containing the compiler version number
    let assembly = format!(
        "; Generated by Leek Compiler v{version}\n\n{file}",
        version = env!("CARGO_PKG_VERSION"),
        file = assembly
    );

    println!(
        "{}",
        assembly
            .lines()
            .enumerate()
            .map(|(i, line)| format!("{:3?}: {line}", i + 1))
            .join("\n")
    );

    // Write the assembly file to disk
    fs::write(&assembly_file_path, assembly)
        .map_err(|_| CodeGenError::TemporaryFileCreationFailure)?;

    // If all we want is to generate asm, then write to disk and stop here
    if let EmitMode::AssemblyFile = compiler_options.emit_mode {
        fs::copy(assembly_file_path, output_path).map_err(|_| CodeGenError::FileOutputFailure)?;
        return Ok(());
    }

    /* Step 2. Assembling */

    // Create a temporary file to pass to the linker
    let object_file_path = build_dir.join("program.o");

    // Invoke the assembler to create the object file
    let mut assembler_command =
        code_generator.create_assembler_command(&assembly_file_path, &object_file_path);

    let output = assembler_command
        .output()
        .expect("Could not invoke assembler!");

    if !output.status.success() {
        // Break on assembler error
        display_buffer!(output.stderr, "ASSEMBLER", "STDERR");
        return Err(CodeGenError::AssemblerError.into());
    } else if compiler_options.verbose {
        // Print assembler output if verbose is passed
        display_buffer!(output.stdout, "ASSEMBLER", "STDOUT");
    }

    // If all we want is to generate an object file, then write to disk and stop here
    if let EmitMode::ObjectFile = compiler_options.emit_mode {
        fs::copy(object_file_path, output_path).map_err(|_| CodeGenError::FileOutputFailure)?;
        return Ok(());
    }

    /* Step 3. Linking */

    // Create a temporary file to pass to the linker
    let executable_file_path = build_dir.join("program");

    let mut linker_command =
        code_generator.create_linker_command(&object_file_path, &executable_file_path);

    let output = linker_command.output().expect("Could not invoke linker!");

    if !output.status.success() {
        // Break on linker error
        display_buffer!(output.stderr, "LINKER", "STDERR");
        return Err(CodeGenError::LinkerError.into());
    } else if compiler_options.verbose {
        // Print linker output if verbose is passed
        display_buffer!(output.stdout, "LINKER", "STDOUT");
    }

    fs::copy(executable_file_path, output_path).map_err(|_| CodeGenError::FileOutputFailure)?;

    /* Step 4. Celebrate! We compiled our program! */

    Ok(())
}
